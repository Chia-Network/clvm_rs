#!/usr/bin/env python3
from hashlib import sha256
from random import randbytes, choice, randint, seed
import sys

seed(1337)

SHA256TREE_BASE_COST = 0
SHA256TREE_COST_PER_CALL = 1300
SHA256TREE_COST_PER_BYTE = 10
MALLOC_COST_PER_BYTE = 10  

SIZE = 30


def tree_hash_atom(b: bytes) -> bytes:
    h = sha256()
    h.update(b"\x01")
    h.update(b)
    return h.digest()

def tree_hash_pair(left_hash: bytes, right_hash: bytes) -> bytes:
    h = sha256()
    h.update(b"\x02")
    h.update(left_hash)
    h.update(right_hash)
    return h.digest()

def random_atom() -> bytes:
    return choice([
        b"",
        b"\x01",
        b"\x02",
        b"foobar",
        randbytes(24),
        randbytes(32),
        randbytes(48)
    ])

def random_tree(depth: int) -> object:
    """Recursively generate random nested pairs (tuples) or atoms"""
    if depth == 0 or randint(0, 2) == 0:
        return random_atom()
    else:
        return (random_tree(depth - 1), random_tree(depth - 1))


def compute_tree_hash_and_cost(obj) -> tuple[bytes, int]:
    """Return (hash, cost) similar to tree_hash_cached_costed"""
    cost = SHA256TREE_COST_PER_CALL
    if isinstance(obj, bytes):
        cost += SHA256TREE_COST_PER_BYTE * len(obj)
        return tree_hash_atom(obj), cost
    else:
        left, right = obj
        cost += SHA256TREE_COST_PER_BYTE * 65
        left_hash, left_cost = compute_tree_hash_and_cost(left)
        right_hash, right_cost = compute_tree_hash_and_cost(right)
        return tree_hash_pair(left_hash, right_hash), cost + left_cost + right_cost


def sexp_repr(obj) -> str:
    """Turn the structure into a Lisp-like representation"""
    if isinstance(obj, bytes):
        if len(obj) == 0:
            return "0"
        return f"0x{obj.hex()}"
    else:
        left, right = obj
        return f"({sexp_repr(left)} . {sexp_repr(right)})"


test_cases = set()
with open("../op-tests/test-sha256tree-hash.txt", "w") as f:
    f.write("; This file was generated by tools/generate-sha256tree-tests.py\n\n")

    for _ in range(SIZE):
        depth = choice(range(1, 6))
        t = random_tree(depth)
        s = sexp_repr(t)
        if s in test_cases:
            continue
        test_cases.add(s)
        h, cost = compute_tree_hash_and_cost(t)
        cost += MALLOC_COST_PER_BYTE * 32
        f.write(f"sha256tree {s} => 0x{h.hex()} | {cost}\n")

