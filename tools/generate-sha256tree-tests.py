#!/usr/bin/env python3
from hashlib import sha256
from pathlib import Path
from random import randbytes, choice, randint, seed
import sys

seed(1337)

# Match Rust cost constants exactly
SHA256TREE_BASE_COST = 30
SHA256TREE_COST_PER_NODE = 3090
SHA256TREE_COST_PER_32_BYTES = 610
MALLOC_COST_PER_BYTE = 10

SIZE = 30


def tree_hash_atom(b: bytes) -> bytes:
    h = sha256()
    h.update(b"\x01")
    h.update(b)
    return h.digest()


def tree_hash_pair(left_hash: bytes, right_hash: bytes) -> bytes:
    h = sha256()
    h.update(b"\x02")
    h.update(left_hash)
    h.update(right_hash)
    return h.digest()


def random_atom() -> bytes:
    return choice([
        b"",
        b"\x01",
        b"\x02",
        b"foobar",
        randbytes(24),
        randbytes(32),
        randbytes(48)
    ])


def random_tree(depth: int):
    """Recursively generate random nested pairs (tuples) or atoms"""
    if depth == 0 or randint(0, 2) == 0:
        return random_atom()
    else:
        return (random_tree(depth - 1), random_tree(depth - 1))


def compute_tree_hash_and_cost(obj) -> tuple[bytes, int]:
    """
    Return (hash, cost) consistent with Rust's tree_hash_cached_costed()
    """
    total_cost = SHA256TREE_BASE_COST
    total_bytes = 0

    def helper(node):
        nonlocal total_cost, total_bytes
        # Every node adds a fixed per-node cost
        total_cost += SHA256TREE_COST_PER_NODE

        if isinstance(node, bytes):
            # Add 1 for the atom marker (b"\x01") + len(bytes)
            added_bytes = 1 + len(node)
            total_bytes += added_bytes
            total_cost += (total_bytes // 32) * SHA256TREE_COST_PER_32_BYTES
            total_bytes %= 32
            return tree_hash_atom(node)
        else:
            left, right = node
            # Add 1 for the pair marker (b"\x02") + 64 bytes of child hashes
            added_bytes = 1 + 64
            total_bytes += added_bytes
            total_cost += (total_bytes // 32) * SHA256TREE_COST_PER_32_BYTES
            total_bytes %= 32
            left_hash = helper(left)
            right_hash = helper(right)
            return tree_hash_pair(left_hash, right_hash)

    h = helper(obj)
    total_cost += MALLOC_COST_PER_BYTE * 32
    return h, total_cost


def sexp_repr(obj) -> str:
    """Turn the structure into a Lisp-like representation"""
    if isinstance(obj, bytes):
        if len(obj) == 0:
            return "0"
        return f"0x{obj.hex()}"
    else:
        left, right = obj
        return f"({sexp_repr(left)} . {sexp_repr(right)})"


test_cases = set()
p = Path(__file__).parent.parent / "op-tests/test-sha256tree-hash.txt"
with open(p, "w") as f:
    f.write("; This file was generated by tools/generate-sha256tree-tests.py\n\n")

    for _ in range(SIZE):
        depth = choice(range(1, 6))
        t = random_tree(depth)
        s = sexp_repr(t)
        if s in test_cases:
            continue
        test_cases.add(s)
        h, cost = compute_tree_hash_and_cost(t)
        f.write(f"sha256tree {s} => 0x{h.hex()} | {cost}\n")
