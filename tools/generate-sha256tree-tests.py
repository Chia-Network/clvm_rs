#!/usr/bin/env python3
from hashlib import sha256
from pathlib import Path
from random import randbytes, choice, randint, seed
import sys
import math

seed(1337)

SHA256TREE_BASE_COST = 87
SHA256TREE_COST_PER_NODE = 500
SHA256TREE_COST_PER_32_BYTES = 64
MALLOC_COST_PER_BYTE = 10

SIZE = 30


def tree_hash_atom(b: bytes) -> bytes:
    h = sha256()
    h.update(b"\x01")
    h.update(b)
    return h.digest()


def tree_hash_pair(left_hash: bytes, right_hash: bytes) -> bytes:
    h = sha256()
    h.update(b"\x02")
    h.update(left_hash)
    h.update(right_hash)
    return h.digest()


def random_atom() -> bytes:
    return choice([
        b"",
        b"\x01",
        b"\x02",
        b"foobar",
        randbytes(24),
        randbytes(32),
        randbytes(48)
    ])


def random_tree(depth: int):
    if depth == 0 or randint(0, 2) == 0:
        return random_atom()
    else:
        return (random_tree(depth - 1), random_tree(depth - 1))

def increment_bytes(amount: int) -> int:
    return math.ceil(amount / 32) * SHA256TREE_COST_PER_32_BYTES


def compute_tree_hash_and_cost(obj) -> tuple[bytes, int]:
    cost = SHA256TREE_COST_PER_NODE

    if isinstance(obj, bytes):
        cost += increment_bytes(len(obj) + 1)
        return tree_hash_atom(obj), cost

    # Pair
    left, right = obj
    cost += increment_bytes(65)
    left_hash, left_cost = compute_tree_hash_and_cost(left)
    right_hash, right_cost = compute_tree_hash_and_cost(right)
    total_cost = cost + left_cost + right_cost
    return tree_hash_pair(left_hash, right_hash), total_cost


def sexp_repr(obj) -> str:
    if isinstance(obj, bytes):
        if len(obj) == 0:
            return "0"
        return f"0x{obj.hex()}"
    else:
        left, right = obj
        return f"({sexp_repr(left)} . {sexp_repr(right)})"


test_cases = set()
p = Path(__file__).parent.parent / "op-tests/test-sha256tree-hash.txt"
with open(p, "w") as f:
    f.write("; This file was generated by tools/generate-sha256tree-tests.py\n\n")

    for _ in range(SIZE):
        depth = choice(range(1, 6))
        t = random_tree(depth)
        s = sexp_repr(t)
        if s in test_cases:
            continue
        test_cases.add(s)
        h, cost = compute_tree_hash_and_cost(t)
        cost += SHA256TREE_BASE_COST
        cost += MALLOC_COST_PER_BYTE * 32
        f.write(f"sha256tree {s} => 0x{h.hex()} | {cost}\n")
