use std::fs;

use clvmr::Allocator;
use num_bigint::BigInt;
use num_integer::Integer;
use rand::{Rng, SeedableRng};
use rand_chacha::ChaCha8Rng;

fn main() {
    // Seed the RNG with a fixed value for reproducibility.
    let mut rng = ChaCha8Rng::seed_from_u64(1337);

    // Generate a random quantity (within a range) of random bytes.
    let mut bytes = |min: usize, max: usize| {
        let len = rng.gen_range(min..=max);
        let mut bytes = vec![0; len];
        rng.fill(&mut bytes[..]);
        bytes
    };

    let mut tests =
        "; This file was generated by tools/src/bin/generate-modpow-tests.rs\n\n".to_string();

    for _ in 0..100 {
        let base = BigInt::from_signed_bytes_be(&bytes(0, 32));

        // Generate a random exponent, but ensure it's positive.
        let mut exponent = BigInt::from_signed_bytes_be(&bytes(0, 32));
        if exponent < BigInt::ZERO {
            exponent = -exponent;
        }

        // Generate a random modulus, but ensure it's non-zero.
        let mut modulus = BigInt::from_signed_bytes_be(&bytes(0, 32));
        if modulus == BigInt::ZERO {
            modulus += 1;
        }

        let base_len = to_atom(base.clone()).len();
        let exponent_len = to_atom(exponent.clone()).len();
        let modulus_len = to_atom(modulus.clone()).len();

        let result = base.modpow(&exponent, &modulus);
        let result_len = to_atom(result.clone()).len();
        let cost = 17000
            + base_len * 38
            + exponent_len * exponent_len * 3
            + modulus_len * modulus_len * 21
            + result_len * 10;

        tests.push_str(&format!(
            "modpow {base} {exponent} {modulus} => {result} | {cost}\n"
        ));
    }

    for _ in 0..100 {
        let base = BigInt::from_signed_bytes_be(&bytes(0, 32));

        // Generate a random exponent, but ensure it's positive.
        let mut modulus = BigInt::from_signed_bytes_be(&bytes(0, 16));
        if modulus == BigInt::ZERO {
            modulus += 1;
        }

        let base_len = to_atom(base.clone()).len();
        let modulus_len = to_atom(modulus.clone()).len();

        // CLVM uses neither `%` and `mod_euclid`, but rather `mod_floor`.
        let result = base.mod_floor(&modulus);
        let result_len = to_atom(result.clone()).len();
        let cost = 988 + base_len * 4 + modulus_len * 4 + result_len * 10;

        tests.push_str(&format!("% {base} {modulus} => {result} | {cost}\n"));
    }

    fs::write("./op-tests/test-modpow.txt", tests).unwrap();
}

// Convert a `BigInt` to a CLVM atom.
fn to_atom(num: BigInt) -> Vec<u8> {
    let mut allocator = Allocator::new();
    let ptr = allocator.new_number(num).unwrap();
    let atom = allocator.atom(ptr);
    atom.as_ref().to_vec()
}
