use std::fs;

use clvmr::Allocator;
use num_bigint::{BigInt, Sign};
use num_integer::Integer;
use rand::{Rng, SeedableRng};
use rand_chacha::ChaCha8Rng;

fn main() {
    // Seed the RNG with a fixed value for reproducibility.
    let mut rng = ChaCha8Rng::seed_from_u64(1337);

    // Generate a random quantity (within a range) of random bytes.
    let mut bytes = |min: usize, max: usize| {
        let len = rng.gen_range(min..=max);
        let mut bytes = vec![0; len];
        rng.fill(&mut bytes[..]);
        bytes
    };

    let mut tests =
        "; This file was generated by tools/src/bin/generate-modpow-tests.rs\n\n".to_string();

    for _ in 0..100 {
        let base = BigInt::from_signed_bytes_be(&bytes(0, 32));

        // Generate a random exponent, but ensure it's positive.
        let exponent = BigInt::from_bytes_be(Sign::Plus, &bytes(0, 32));

        // Generate a random modulus, but ensure it's non-zero.
        let mut modulus = BigInt::from_signed_bytes_be(&bytes(0, 32));
        if modulus == BigInt::ZERO {
            modulus += 1;
        }

        let base_len = atom_len(base.clone());
        let exponent_len = atom_len(exponent.clone());
        let modulus_len = atom_len(modulus.clone());

        let result = base.modpow(&exponent, &modulus);
        let result_len = atom_len(result.clone());
        let cost = 17000
            + base_len * 38
            + exponent_len * exponent_len * 3
            + modulus_len * modulus_len * 21
            + result_len * 10;

        tests.push_str(&format!(
            "modpow {base} {exponent} {modulus} => {result} | {cost}\n"
        ));
    }

    for _ in 0..100 {
        let base = BigInt::from_signed_bytes_be(&bytes(0, 32));

        // Generate a random exponent, but ensure it's positive.
        let mut modulus = BigInt::from_signed_bytes_be(&bytes(0, 16));
        if modulus == BigInt::ZERO {
            modulus += 1;
        }

        let base_len = atom_len(base.clone());
        let modulus_len = atom_len(modulus.clone());

        // CLVM uses neither `%` nor `mod_euclid`, but rather `mod_floor`.
        let result = base.mod_floor(&modulus);
        let result_len = atom_len(result.clone());
        let cost = 988 + base_len * 4 + modulus_len * 4 + result_len * 10;

        tests.push_str(&format!("% {base} {modulus} => {result} | {cost}\n"));
    }

    fs::write("./op-tests/test-modpow.txt", tests).unwrap();
}

// Convert a `BigInt` to a CLVM atom.
fn atom_len(num: BigInt) -> usize {
    let mut allocator = Allocator::new();
    let ptr = allocator.new_number(num).unwrap();
    allocator.atom_len(ptr)
}
